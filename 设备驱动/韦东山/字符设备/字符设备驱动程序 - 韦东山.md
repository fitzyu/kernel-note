#字符设备驱动程序

##字符驱动程序概述
uboot 启动内核
内核 启动应用
应用 读写文件 点灯 获取按键值
应用中的open read write要能够调用驱动中的xxx_open xxx_read xxx_write

int main()
{
  int fd1, df2l
  int val = 1;

  fd1 = open("/dev/led", O_RDWR);
  write(fd1, &val, 4);

  fd1 = open("hello.txt", O_RDWR);
  write(fd2, &val, 4);
}

这里边的open是由C库实现的
驱动属于内核一部分

open read write实现是执行一条汇编指令swi val
swi val会引发一个异常，像中断一样，会进入内核的异常处理函数中

虽然应用程序中对磁盘文件还是驱动文件都是调用相同的函数open和write，但是最终在驱动层却是调用不同的驱动文件

驱动程序框架就是帮助open write 找到对应模块的xxx_open xxx_write

# 字符设备驱动程序之LED驱动程序——编写编译
驱动程序框架

1.写出led_open led_write
2.如何把驱动接口告诉内核 定义
  a.一个file_operations结构 然后填充它
    应用程序的接口在 驱动程序中都有对应的函数
  b.把这个结构告诉内核,通过函数register_chrdev()
  c.谁来调用它 驱动的入口函数first_drv_init
   调用module_init这个宏，里边有一个函数指针，当内核加载模块时就会找到这个指针

应用程序是如何找到对应的驱动程序呢 是通过设备类型（字符设备）设备号找到注册时file_operation

参考代码fitst_drv

进入到文件系统 使用命令cat /proc/devices 查看当前系统下的设备
第一个程序比较简单
主要用到两个函数
```
static inline int register_chrdev(unsigned int major, const char *name,
				  const struct file_operations *fops)；
static inline void unregister_chrdev(unsigned int major, const char *name)；
```

使用注册完成后需要使用 mknod /dev/xxx c 主设备号 次设备号
然后才能调用程序执行

驱动程序可以自动在/dev下创建节点
class_create
device_create

我使用的版本是3.5

# 写一个点灯的驱动
1 框架
2 完善 硬件的操作
 a. 看原理图，确定引脚
 b. 看4412的手册
 c. 写代码 单片机是直接操作物理地址，Linux只能操作虚拟地址，使用IO的映射

 查看4412的原理图
 查看Tiny4412-1412 查找到
 LED1所对引脚GPM4_0
 LED2所对引脚GPM4_1
 LED3所对引脚GPM4_2
 LED4所对引脚GPM4_3

 设置GPM4CON寄存器 配置GPM4DAT寄存器
 查询三星寄存器手册 物理地址是GPM4CON
Base Address: 0x1100_0000
Address = Base Address + 0x02E00
GPM4DAT
Base Address: 0x1100_0000
Address = Base Address + 0x02E4

还有一种思路是可以控制单盏灯通过函数device_create循环生成/dev下边的设备，这些设备主设备号相同，次设备号不同,根据不同的次设备号来控制LED灯

# 查询方法获得按键值
按键驱动 查询的方式
1.写出框架
2.硬件操作

给sysfs提供更多的信息
使用udev机制可以自动创建设备节点

查看原理图TINY4412SDK-1506
K1 XEINT26 GPx3_1
K2 XEINT27 GPx3_2
K3 XEINT28 GPx3_3
K4 XEINT29 GPx3_4
