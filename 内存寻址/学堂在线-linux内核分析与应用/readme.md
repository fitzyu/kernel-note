#内存寻址

arm 是哈佛体系
intel amd 是冯诺依曼体系

16位CPU
1M的内存 分成了数个64K的Memory block
段寄存器指向每个段的基地址

段描述了一块有限的内存区域，区域的起始位置存放专门的寄存器，也就是段寄存器中

把16位的地址寻址到1M的地址空间，把16位的段地址左移4位后再与16位的偏移量相加，遍获得一个20位的内存地址

从16位内存地址到20位实际地址的转换，或者为“映射”，这种模式也叫“实模式”

保护模式

访问内存不能直接从段寄存器中获得起始地址

32位COU 寻址能力达到4GB
在保护模式下，段的范围不再受限于64K 可以达到4GB

页表寄存器 CR0-CR3 可以控制实模式或者保护模式

参考 深入理解Linux内核第二章 和 Intel 手册
     www.faqs.orf

问题？ 1.为什么要引入保护模式？
      2.保护模式到底保护什么？
      3.为什么能达到保护这些对象的目的？

#保护模式下的段机制
1.gcc -S hello.c -o hello.s // 编译
2.gcc -c hello.s -o hello.o // 汇编
3.gcc hello.c -o a.out // 链接
4../a.out // 装载并执行
objdump -d a.out 反汇编

链接之后形成的地址是实地址还是虚拟地址
装入程序装入到虚拟内存还是物理内存
Cpu 访问的虚拟地址还是物理地址？

CPU 把虚拟地址发送给MMU 然后再把物理地址发送给存储器

MMU 第一个阶段是吧虚拟地址转换为线性地址 通过段机制
第二个阶段是把线性地址转换为物理地址 是通过分页机制
MMU是硬件单元，是把虚拟地址转换为物理地址

思考： 在硬件设计和操作系统设计中，到底进行怎样的取舍和折中？

#分页机制
分页是在分段之后进行的，它的目的是完成从线性地址到物理地址的转化过程

分页就是讲虚拟地址空间或线性地址空间划分成若干大小相等的片，称为页，对物理地址空间分成与页大小相等的快，称为块或页面

分页是为了每个进程可以拥有自己独立的虚拟内存空间

页表是一种映射机制，存放的是虚拟地址空间与物理地址空间的映射关系。也就是页号对应的块号

地址转换过程
最高十位作为页目录项的索引，将它乘以4，每一个页表项占4个字节，然后与CR3中的页目录项的起始地址相加，这样就获得相应目录项在内存的地址。接着从这个地址开始读取32位的页目录项取出其最高的20位，然后再给最低的12位补零，就形成页表在内存的起始地址，第三步呢，用中间的十位作为页表中的页表项的索引，依然将它乘以4，与页表的起始地址相加，获得相应页表项在内存的地址，从这个地址开始读取32位的页表项，取出它高二十位，再讲线性地址的第11位到0位放在低12位，最终形成32位的物理地址

这个过程是硬件还是操作系统完成的？

源代码中与页表相关的头文件如下：
include/asm-generic/pgtable-nopud.h
include/asm-generic/pgtable-nopmd.h
arch/x86/include/asm/pgtable-2level*.h
arch/x86/include/asm/pgtable-3level*.h
arch/x86/include/asm/pgtable_64*.h

问题：页的大小不仅只有4KB,还可以是4MB等更大的，那么在海量存储中，如何使用大页内存？

#进程概述
操作系统如何对待千变万化的程序
进程的执行和加载
使用top命令感受进程的变化
调用fork徐彤用来创建新的进程
linux内核中把对进程的描述结构叫做task_struct 进程控制块
该结构体有几百个字段
包括状态信息，链接信息，各种标识符，进程间通信信息 时间和定时器信息 调度信息 文件系统信息 虚拟内存信息 处理器环境信息

sched.h

PCB与内核栈放在一起有什么好处
(1)内核可以方便而快捷地找到PCB
(2)避免在创建进程时动态分配额外的内存
在linux中，为了表示当前正在运行的进程，定义了一个current宏，可以把它当做全局变量来用。current->pid返回正在执行的进程的标识符

进程的组织方式--进程链表

容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”
cgroups技术是用来制造约束的主要手段
namespace技术则是用来修改进程视图的主要方法
